From 2069c10002d319635cfb3a1a54a9a4875be75c3d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Robert=20L=C3=B6hning?= <robert.loehning@qt.io>
Date: Fri, 12 Sep 2025 21:22:58 +0200
Subject: Don't create group nodes which will be deleted anyway

The old code first created the nodes, then checked whether their parent
element has the right type and deleted them if not. This was wasted
effort and could also lead to dangling pointers.

Instead, first check the parent's type and only create the node if that
matches.

Task-number: QTBUG-139961
Pick-to: 6.10.0 6.10 6.9 6.8
Change-Id: Ifa870efbd5f336b34b81aa09b6fe79fb7fc826b9
Reviewed-by: Hatem ElKharashy <hatem.elkharashy@qt.io>
(cherry picked from commit 7e8898903265d931df0aa54b3913f2c49d4d7bf2)
---
 src/svg/qsvghandler.cpp                      | 60 ++++++++++----------
 tests/auto/qsvgrenderer/tst_qsvgrenderer.cpp | 26 +++++++++
 2 files changed, 56 insertions(+), 30 deletions(-)

diff --git x/qtsvg/src/svg/qsvghandler.cpp y/qtsvg/src/svg/qsvghandler.cpp
index c871a20cdc722e7feab6dd3273da708140f54f7c..edbad89803a0078b771e16304be987c84a12bdea 100644
--- x/qtsvg/src/svg/qsvghandler.cpp
+++ y/qtsvg/src/svg/qsvghandler.cpp
@@ -4717,46 +4717,46 @@ bool QSvgHandler::startElement(const QString &localName,
 
     if (FactoryMethod method = findGroupFactory(localName, options())) {
         //group
-        node = method(m_doc ? m_nodes.top() : 0, attributes, this);
-
-        if (node) {
-            if (!m_doc) {
+        if (!m_doc) {
+            node = method(nullptr, attributes, this);
+            if (node) {
                 Q_ASSERT(node->type() == QSvgNode::Doc);
                 m_doc = static_cast<QSvgTinyDocument*>(node);
-            } else {
-                switch (m_nodes.top()->type()) {
-                case QSvgNode::Doc:
-                case QSvgNode::Group:
-                case QSvgNode::Defs:
-                case QSvgNode::Switch:
-                case QSvgNode::Mask:
-                case QSvgNode::Symbol:
-                case QSvgNode::Marker:
-                case QSvgNode::Pattern:
-                {
+            }
+        } else {
+            switch (m_nodes.top()->type()) {
+            case QSvgNode::Doc:
+            case QSvgNode::Group:
+            case QSvgNode::Defs:
+            case QSvgNode::Switch:
+            case QSvgNode::Mask:
+            case QSvgNode::Symbol:
+            case QSvgNode::Marker:
+            case QSvgNode::Pattern:
+            {
+                node = method(m_nodes.top(), attributes, this);
+                if (node) {
                     QSvgStructureNode *group =
                         static_cast<QSvgStructureNode*>(m_nodes.top());
                     group->addChild(node, someId(attributes));
                 }
-                    break;
-                default:
-                    const QByteArray msg = QByteArrayLiteral("Could not add child element to parent element because the types are incorrect.");
-                    qCWarning(lcSvgHandler, "%s", prefixMessage(msg, xml).constData());
-                    delete node;
-                    node = 0;
-                    break;
-                }
             }
+                break;
+            default:
+                const QByteArray msg = QByteArrayLiteral("Could not add child element to parent element because the types are incorrect.");
+                qCWarning(lcSvgHandler, "%s", prefixMessage(msg, xml).constData());
+                break;
+            }
+        }
 
-            if (node) {
-                parseCoreNode(node, attributes);
+        if (node) {
+            parseCoreNode(node, attributes);
 #ifndef QT_NO_CSSPARSER
-                cssStyleLookup(node, this, m_selector);
+            cssStyleLookup(node, this, m_selector);
 #endif
-                parseStyle(node, attributes, this);
-                if (node->type() == QSvgNode::Filter)
-                    m_toBeResolved.append(node);
-            }
+            parseStyle(node, attributes, this);
+            if (node->type() == QSvgNode::Filter)
+                m_toBeResolved.append(node);
         }
     } else if (FactoryMethod method = findGraphicsFactory(localName, options())) {
         //rendering element
diff --git x/qtsvg/tests/auto/qsvgrenderer/tst_qsvgrenderer.cpp y/qtsvg/tests/auto/qsvgrenderer/tst_qsvgrenderer.cpp
index 56f6664328ead7c390d2b0c724566c8160bdcd8e..9886d5558c5e6756d1a6f1e47bf11922af556814 100644
--- x/qtsvg/tests/auto/qsvgrenderer/tst_qsvgrenderer.cpp
+++ y/qtsvg/tests/auto/qsvgrenderer/tst_qsvgrenderer.cpp
@@ -81,6 +81,7 @@ private slots:
     void testSymbol();
     void testMarker();
     void testPatternElement();
+    void testMisplacedElement();
     void testCycles();
     void testFeFlood();
     void testFeOffset();
@@ -2127,6 +2128,31 @@ void tst_QSvgRenderer::testPatternElement()
     QCOMPARE(refImage, image);
 }
 
+void tst_QSvgRenderer::testMisplacedElement()
+{
+    // This input caused a QSvgPattern node to be created with a QSvgPatternStyle referencing to it.
+    // The code then detected that the <pattern> element is misplaced in the <text> element and
+    // deleted it. That left behind the QSvgPatternStyle pointing to the deleted QSvgPattern. That
+    // was reported when running the test with ASAN or UBSAN.
+    QByteArray svg(R"(<svg>
+                      <text><pattern id="ptn" width="4" height="4"/></text>
+                      <g fill="url(#ptn) "/>
+                      </svg>)");
+
+    QImage image(20, 20, QImage::Format_ARGB32_Premultiplied);
+    image.fill(Qt::green);
+    QImage refImage = image.copy();
+
+    QTest::ignoreMessage(QtWarningMsg, "<input>:2:68: Could not add child element to parent "
+                                       "element because the types are incorrect.");
+    QTest::ignoreMessage(QtWarningMsg, "<input>:4:28: Could not resolve property: #ptn");
+
+    QSvgRenderer renderer(svg);
+    QPainter painter(&image);
+    renderer.render(&painter);
+    QCOMPARE(image, refImage);
+}
+
 void tst_QSvgRenderer::testCycles()
 {
     QByteArray svgDoc(R"(<svg viewBox="0 0 200 200">
